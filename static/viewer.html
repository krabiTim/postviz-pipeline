<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PostViz Camera Path Viewer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #111; color: #ccc; font-family: monospace; overflow: hidden; }

  #canvas-container { position: fixed; inset: 0; }

  /* Top bar */
  #topbar {
    position: fixed; top: 0; left: 0; right: 0; height: 40px;
    background: rgba(0,0,0,0.75); border-bottom: 1px solid #333;
    display: flex; align-items: center; gap: 12px; padding: 0 12px;
    z-index: 10;
  }
  #topbar h1 { font-size: 13px; color: #fff; letter-spacing: 0.05em; white-space: nowrap; }
  #shot-select {
    background: #1a1a1a; border: 1px solid #444; color: #ddd;
    padding: 3px 8px; font-family: monospace; font-size: 12px;
    border-radius: 3px; cursor: pointer; min-width: 200px;
  }
  #shot-select:focus { outline: 1px solid #666; }
  #load-btn {
    background: #2a4a2a; border: 1px solid #4a8a4a; color: #8f8;
    padding: 3px 10px; font-family: monospace; font-size: 12px;
    border-radius: 3px; cursor: pointer;
  }
  #load-btn:hover { background: #3a6a3a; }
  #status-msg { font-size: 11px; color: #888; flex: 1; }

  /* Info panel */
  #info-panel {
    position: fixed; top: 48px; right: 12px;
    background: rgba(0,0,0,0.72); border: 1px solid #333;
    border-radius: 4px; padding: 10px 14px; min-width: 200px;
    font-size: 11px; line-height: 1.8; z-index: 10;
  }
  #info-panel .label { color: #666; }
  #info-panel .val   { color: #ccc; }
  #info-panel .good  { color: #8f8; }
  #info-panel .warn  { color: #fa0; }
  #info-panel .bad   { color: #f44; }
  #info-panel hr { border: none; border-top: 1px solid #2a2a2a; margin: 6px 0; }

  /* Timeline */
  #timeline {
    position: fixed; bottom: 0; left: 0; right: 0; height: 48px;
    background: rgba(0,0,0,0.82); border-top: 1px solid #333;
    display: flex; align-items: center; gap: 10px; padding: 0 14px;
    z-index: 10;
  }
  #play-btn {
    background: #1a2a3a; border: 1px solid #3a6a9a; color: #6af;
    width: 30px; height: 26px; font-size: 14px; border-radius: 3px;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
  }
  #play-btn:hover { background: #2a3a4a; }
  #scrubber {
    flex: 1; -webkit-appearance: none; appearance: none;
    height: 4px; border-radius: 2px; background: #333; cursor: pointer;
    outline: none;
  }
  #scrubber::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px;
    border-radius: 50%; background: #6af; cursor: pointer;
    box-shadow: 0 0 4px #06f;
  }
  #frame-label { font-size: 11px; color: #888; white-space: nowrap; min-width: 80px; }
  #reset-btn, #follow-btn {
    background: #1a1a1a; border: 1px solid #444; color: #999;
    padding: 3px 8px; font-family: monospace; font-size: 11px;
    border-radius: 3px; cursor: pointer;
  }
  #reset-btn:hover, #follow-btn:hover { background: #2a2a2a; }
  #follow-btn.active { border-color: #6af; color: #6af; background: #0a1a2a; }

  /* Loading overlay */
  #loading {
    position: fixed; inset: 0; background: rgba(0,0,0,0.85);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 100; gap: 14px;
  }
  #loading.hidden { display: none; }
  #loading p { font-size: 13px; color: #aaa; }
  .spinner {
    width: 36px; height: 36px; border: 3px solid #333;
    border-top-color: #6af; border-radius: 50%; animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  #loading-bar-bg {
    width: 260px; height: 4px; background: #222; border-radius: 2px; overflow: hidden;
  }
  #loading-bar {
    height: 100%; width: 0%; background: #6af; border-radius: 2px;
    transition: width 0.15s ease;
  }
</style>
</head>
<body>

<div id="canvas-container"></div>

<div id="topbar">
  <h1>CAMERA PATH VIEWER</h1>
  <select id="shot-select"><option value="">— select shot —</option></select>
  <button id="load-btn">LOAD</button>
  <span id="status-msg">Select a shot and click LOAD</span>
</div>

<div id="info-panel">
  <div><span class="label">Shot: </span><span class="val" id="ip-shot">—</span></div>
  <div><span class="label">Frames: </span><span class="val" id="ip-frames">—</span></div>
  <div><span class="label">Registered: </span><span class="val" id="ip-reg">—</span></div>
  <hr>
  <div><span class="label">Model: </span><span class="val" id="ip-model">—</span></div>
  <div><span class="label">Focal: </span><span class="val" id="ip-focal">—</span></div>
  <div><span class="label">FOV: </span><span class="val" id="ip-fov">—</span></div>
  <hr>
  <div><span class="label">Solve error: </span><span id="ip-err">—</span></div>
  <hr>
  <div><span class="label">Frame: </span><span class="val" id="ip-frame">—</span></div>
  <div><span class="label">Reg: </span><span class="val" id="ip-reg2">—</span></div>
</div>

<div id="timeline">
  <button id="play-btn">&#9654;</button>
  <input type="range" id="scrubber" min="0" max="100" value="0" step="1">
  <span id="frame-label">0 / 0</span>
  <button id="reset-btn">RESET CAM</button>
  <button id="follow-btn">FOLLOW CAM</button>
</div>

<div id="loading">
  <div class="spinner"></div>
  <p id="loading-msg">Initialising…</p>
  <div id="loading-bar-bg"><div id="loading-bar"></div></div>
</div>

<!-- Three.js r128 — served locally, no CDN dependency -->
<script src="/static/three.min.js"></script>
<script src="/static/OrbitControls.js"></script>
<script src="/static/PLYLoader.js"></script>

<script>
"use strict";

// ── Three.js scene setup ──────────────────────────────────────────────────────

const container = document.getElementById("canvas-container");
const renderer  = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0d0d0d);
container.appendChild(renderer.domElement);

const scene   = new THREE.Scene();
const camera  = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 2000);
camera.position.set(0, 3, 12);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance   = 0.05;
controls.maxDistance   = 500;
controls.screenSpacePanning = true;

// Grid + axes
const gridHelper = new THREE.GridHelper(20, 20, 0x222222, 0x1a1a1a);
scene.add(gridHelper);

const axesHelper = new THREE.AxesHelper(0.5);
scene.add(axesHelper);

// Ambient light (helps frustum wireframes)
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ── Scene objects (swapped out on each LOAD) ─────────────────────────────────

let sceneGroup = new THREE.Group();
scene.add(sceneGroup);

let frameData    = [];    // per-frame info from API
let totalFrames  = 0;
let frustums     = [];    // one mesh per frame (some null for unregistered)
let activeFrustum = null;

// Per-frame point clouds
let globalPointCloud = null;   // the static whole-solve PLY
let framePoints      = [];     // THREE.Points per frame index (null if not loaded)
let activeFrameCloud = null;   // currently visible frame cloud
let frameCloudMode   = false;  // true once first frame cloud has loaded
let framePlyCount    = 0;      // number of per-frame PLYs reported by API
let currentShotName  = "";     // for frame_ply fetch URL

// ── Animation state ───────────────────────────────────────────────────────────

let playing    = false;
let followCam  = false;
let currentFrame = 0;
let lastTime   = null;
let fps        = 24.0;

// ── UI refs ───────────────────────────────────────────────────────────────────

const shotSelect  = document.getElementById("shot-select");
const loadBtn     = document.getElementById("load-btn");
const statusMsg   = document.getElementById("status-msg");
const scrubber    = document.getElementById("scrubber");
const frameLabel  = document.getElementById("frame-label");
const playBtn     = document.getElementById("play-btn");
const resetBtn    = document.getElementById("reset-btn");
const followBtn   = document.getElementById("follow-btn");
const loadingDiv  = document.getElementById("loading");
const loadingMsg  = document.getElementById("loading-msg");

// ── Populate shot list ────────────────────────────────────────────────────────

async function populateShots() {
  try {
    const resp = await fetch("/api/shots");
    const data = await resp.json();
    shotSelect.innerHTML = "<option value=''>— select shot —</option>";
    for (const s of data.shots) {
      const opt = document.createElement("option");
      opt.value = opt.textContent = s;
      shotSelect.appendChild(opt);
    }
    if (data.shots.length > 0) {
      shotSelect.value = data.shots[0];
      statusMsg.textContent = `${data.shots.length} shot(s) found`;
    } else {
      statusMsg.textContent = "No solved shots found";
    }
  } catch (e) {
    statusMsg.textContent = "Could not reach API";
  }
}

// ── Load shot ─────────────────────────────────────────────────────────────────

async function loadShot(shotName) {
  showLoading("Fetching scene data…");

  // Clear previous scene (scene.remove works in all Three.js versions)
  scene.remove(sceneGroup);
  sceneGroup = new THREE.Group();
  // COLMAP is Y-down / Z-forward (OpenCV). Three.js is Y-up / Z-toward-viewer.
  // Flip Y and Z on the group so all scene content renders right-side up.
  sceneGroup.scale.set(1, -1, -1);
  scene.add(sceneGroup);
  frustums = [];
  activeFrustum = null;
  currentFrame = 0;
  playing = false;
  playBtn.innerHTML = "&#9654;";
  // Reset per-frame cloud state
  globalPointCloud = null;
  framePoints = [];
  activeFrameCloud = null;
  frameCloudMode = false;
  framePlyCount = 0;
  currentShotName = shotName;

  let sceneData;
  try {
    showLoading("Fetching scene data…", 5);
    const resp = await fetch(`/api/scene/${encodeURIComponent(shotName)}`);
    if (!resp.ok) throw new Error(await resp.text());
    sceneData = await resp.json();
    showLoading("Scene data received", 10);
  } catch (e) {
    hideLoading();
    statusMsg.textContent = "Scene load failed: " + e.message;
    return;
  }

  frameData      = sceneData.camera_path;
  totalFrames    = sceneData.total_frames;
  fps            = sceneData.fps > 0 ? sceneData.fps : 24.0;
  framePlyCount  = sceneData.frame_ply_count || 0;

  updateInfoPanel(sceneData);

  // Scrubber
  scrubber.min   = 0;
  scrubber.max   = Math.max(0, totalFrames - 1);
  scrubber.value = 0;
  updateFrameLabel(0);

  // Build scene geometry
  try {
    await buildScene(sceneData);
  } catch (e) {
    console.error("buildScene error:", e);
    statusMsg.textContent = "Scene build error: " + e.message;
  }
  hideLoading();  // always runs, even on error
  statusMsg.textContent = `Loaded: ${shotName}`;
  setFrame(0);
}

// ── Build 3D scene geometry ───────────────────────────────────────────────────

async function buildScene(sceneData) {
  // 1. Point cloud (PLY load dominates — maps to 10–80% of bar)
  if (sceneData.ply_url) {
    await loadPLY(sceneData.ply_url);
  } else {
    showLoading("No point cloud available", 80);
  }

  // 2. Camera path: collect registered positions for spline
  showLoading("Building camera path…", 82);
  const registeredFrames = frameData.filter(f => f.registered);
  if (registeredFrames.length >= 2) {
    buildCameraPath(registeredFrames);
  }

  // 3. Frustums for every registered frame
  showLoading(`Building frustums (${registeredFrames.length} cameras)…`, 88);
  const intr = sceneData.intrinsics;
  for (let i = 0; i < frameData.length; i++) {
    const f = frameData[i];
    if (f.registered) {
      const m = buildFrustumMesh(f, intr, 0.3);
      if (m) {
        m.visible = false;
        sceneGroup.add(m);
        frustums[i] = m;
      }
    } else {
      frustums[i] = null;
    }
  }

  // 4. Frame spheres (small dot per registered frame)
  showLoading("Placing camera markers…", 94);
  const sphereGeo = new THREE.SphereGeometry(0.025, 6, 6);
  const sphereMat = new THREE.MeshBasicMaterial({ color: 0x4488cc });
  for (const f of registeredFrames) {
    const s = new THREE.Mesh(sphereGeo, sphereMat);
    s.position.set(f.position[0], f.position[1], f.position[2]);
    sceneGroup.add(s);
  }

  // 5. Kick off background per-frame PLY pre-loading (non-blocking)
  if (framePlyCount > 0) {
    loadAllFramePLYs(currentShotName, framePlyCount);  // intentionally not awaited
  }

  // 6. Auto-fit orbit target to scene centre
  if (registeredFrames.length > 0) {
    let cx = 0, cy = 0, cz = 0;
    for (const f of registeredFrames) {
      cx += f.position[0]; cy += f.position[1]; cz += f.position[2];
    }
    const n = registeredFrames.length;
    const cxA = cx/n, cyA = cy/n, czA = cz/n;

    // Span in COLMAP space
    let maxD = 0;
    for (const f of registeredFrames) {
      const dx = f.position[0]-cxA, dy = f.position[1]-cyA, dz = f.position[2]-czA;
      maxD = Math.max(maxD, Math.sqrt(dx*dx + dy*dy + dz*dz));
    }

    // Centre and camera in Three.js world coords (Y and Z flipped to match sceneGroup)
    const centre = new THREE.Vector3(cxA, -cyA, -czA);
    controls.target.copy(centre);
    const dist = Math.max(maxD * 2.5, 2);
    camera.position.set(centre.x, centre.y + dist * 0.5, centre.z + dist);
    controls.update();
  }
}

// ── PLY loader ────────────────────────────────────────────────────────────────
// Uses fetch() + PLYLoader.parse() instead of PLYLoader.load() (XHR-based).
// XHR can stall on binary responses over localhost and never fire any callback,
// leaving the loading Promise unresolved forever. fetch() gives us proper
// async/await with stream progress and a clean error path.

async function loadPLY(plyUrl) {
  showLoading("Loading point cloud… 0%", 10);

  // Safety timeout: if PLY load takes > 15s, continue without it
  let timedOut = false;
  const timeout = setTimeout(() => {
    timedOut = true;
    console.warn("PLY load timed out — continuing without point cloud");
    statusMsg.textContent = "Point cloud timed out — scene loaded without PLY";
    showLoading("Point cloud timed out", 80);
  }, 15000);

  try {
    const resp = await fetch(plyUrl);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

    // Stream body with progress
    const contentLength = parseInt(resp.headers.get("content-length") || "0");
    const reader = resp.body.getReader();
    const chunks = [];
    let loaded = 0;

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      loaded += value.length;
      if (contentLength) {
        const pct = 10 + Math.round((loaded / contentLength) * 68);
        showLoading(`Loading point cloud… ${Math.round(loaded / contentLength * 100)}%`, pct);
      }
    }

    if (timedOut) return;
    clearTimeout(timeout);

    // Combine chunks into one ArrayBuffer
    const buffer = new Uint8Array(loaded);
    let offset = 0;
    for (const chunk of chunks) { buffer.set(chunk, offset); offset += chunk.length; }

    // Parse and add to scene
    const loader = new THREE.PLYLoader();
    const geometry = loader.parse(buffer.buffer);
    geometry.computeBoundingBox();
    const hasColors = geometry.hasAttribute("color");
    const mat = new THREE.PointsMaterial({
      size: 0.025,
      vertexColors: hasColors,
      color: hasColors ? 0xffffff : 0x88aacc,
    });
    globalPointCloud = new THREE.Points(geometry, mat);
    sceneGroup.add(globalPointCloud);
    showLoading("Point cloud loaded", 80);

  } catch (err) {
    clearTimeout(timeout);
    if (!timedOut) {
      console.error("PLY load error:", err);
      statusMsg.textContent = "Point cloud load failed — continuing without PLY";
      showLoading("Point cloud unavailable (check console)", 80);
    }
  }
}

// ── Per-frame PLY background loader ──────────────────────────────────────────
// Loads per-frame PLYs one-by-one in background after scene is visible.
// On first success: hides global PLY and switches to per-frame swap mode.

async function loadAllFramePLYs(shotName, totalFramePLYs) {
  framePoints = new Array(totalFrames).fill(null);
  const loader = new THREE.PLYLoader();
  let loaded = 0;

  for (let i = 0; i < frameData.length; i++) {
    const fd = frameData[i];
    if (!fd || !fd.registered) continue;

    const frameIdx = fd.frame_index;
    try {
      const resp = await fetch(`/api/frame_ply/${encodeURIComponent(shotName)}/${frameIdx}`);
      if (!resp.ok) continue;

      const reader = resp.body.getReader();
      const chunks = [];
      let loadedBytes = 0;
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
        loadedBytes += value.length;
      }

      // If the user loaded a different shot while we were fetching, abort
      if (currentShotName !== shotName) return;

      const buffer = new Uint8Array(loadedBytes);
      let offset = 0;
      for (const chunk of chunks) { buffer.set(chunk, offset); offset += chunk.length; }

      const geometry = loader.parse(buffer.buffer);
      const hasColors = geometry.hasAttribute("color");
      const mat = new THREE.PointsMaterial({
        size: 0.03,
        vertexColors: hasColors,
        color: hasColors ? 0xffffff : 0x88aacc,
      });
      const pts = new THREE.Points(geometry, mat);
      pts.visible = false;
      sceneGroup.add(pts);
      framePoints[i] = pts;

      loaded++;

      // First cloud loaded: switch from global to per-frame mode
      if (!frameCloudMode) {
        frameCloudMode = true;
        if (globalPointCloud) globalPointCloud.visible = false;
        setFrame(currentFrame);
      }

      statusMsg.textContent = `Loading frame clouds… ${loaded} / ${totalFramePLYs}`;
    } catch (e) {
      console.warn(`Frame PLY ${frameIdx} failed:`, e);
    }
  }

  if (currentShotName === shotName) {
    statusMsg.textContent = `Loaded: ${shotName} — ${loaded} frame clouds`;
  }
}

// ── Camera path spline ────────────────────────────────────────────────────────

function buildCameraPath(frames) {
  const pts = frames.map(f => new THREE.Vector3(f.position[0], f.position[1], f.position[2]));
  const curve = new THREE.CatmullRomCurve3(pts);
  const splinePts = curve.getPoints(Math.min(pts.length * 8, 800));
  const geo = new THREE.BufferGeometry().setFromPoints(splinePts);
  const mat = new THREE.LineBasicMaterial({ color: 0x226688, transparent: true, opacity: 0.6 });
  const line = new THREE.Line(geo, mat);
  sceneGroup.add(line);
}

// ── Frustum geometry ──────────────────────────────────────────────────────────
// rotation_matrix in JSON is R^T (3×3, row-major = world-from-camera).
// To transform a camera-space vector v to world space:
//   world = R^T * v + position
// where R^T[row][col] means we do: world_x = sum_j R^T[row=0][j] * v[j]
// i.e. standard matrix-vector product with the stored row-major matrix.

function applyRotT(rotMat, v) {
  // rotMat is [[r00,r01,r02],[r10,r11,r12],[r20,r21,r22]] (row-major, R^T)
  const r = rotMat;
  return [
    r[0][0]*v[0] + r[0][1]*v[1] + r[0][2]*v[2],
    r[1][0]*v[0] + r[1][1]*v[1] + r[1][2]*v[2],
    r[2][0]*v[0] + r[2][1]*v[1] + r[2][2]*v[2],
  ];
}

function buildFrustumMesh(frame, intr, scale) {
  // Guard: skip if position or rotation data is missing
  if (!frame.position || !frame.rotation_matrix) return null;
  const rotT = frame.rotation_matrix;
  if (!Array.isArray(rotT) || rotT.length < 3 || !rotT[0]) return null;
  const pos  = frame.position;       // [x,y,z] world

  // Frustum corners in camera space at depth=scale
  // Camera convention: +X right, +Y down, +Z forward (COLMAP/OpenCV)
  const aspect = intr.aspect_ratio || 1.778;
  const fovY   = (intr.fov_y_deg || 30.0) * Math.PI / 180.0;
  const halfH  = Math.tan(fovY / 2) * scale;
  const halfW  = halfH * aspect;
  const d      = scale;

  const camCorners = [
    [-halfW, -halfH,  d],  // top-left
    [ halfW, -halfH,  d],  // top-right
    [ halfW,  halfH,  d],  // bottom-right
    [-halfW,  halfH,  d],  // bottom-left
  ];

  const worldCorners = camCorners.map(c => {
    const w = applyRotT(rotT, c);
    return new THREE.Vector3(pos[0]+w[0], pos[1]+w[1], pos[2]+w[2]);
  });
  const origin = new THREE.Vector3(pos[0], pos[1], pos[2]);

  // Build line segments: 4 edges from apex, 4 edges of near rectangle
  const verts = [];
  for (const wc of worldCorners) {
    verts.push(origin.x, origin.y, origin.z);
    verts.push(wc.x, wc.y, wc.z);
  }
  // Rectangle
  for (let i = 0; i < 4; i++) {
    const a = worldCorners[i];
    const b = worldCorners[(i+1)%4];
    verts.push(a.x, a.y, a.z, b.x, b.y, b.z);
  }
  // Up direction marker: small tick from apex toward camera "up" (-Y cam = up)
  const upCam = [0, -0.3*scale, 0];
  const upW   = applyRotT(rotT, upCam);
  const upTip = new THREE.Vector3(pos[0]+upW[0], pos[1]+upW[1], pos[2]+upW[2]);
  verts.push(origin.x, origin.y, origin.z, upTip.x, upTip.y, upTip.z);

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(verts, 3));
  const mat = new THREE.LineBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.85 });
  return new THREE.LineSegments(geo, mat);
}

// ── Frame update ──────────────────────────────────────────────────────────────

function setFrame(idx) {
  idx = Math.max(0, Math.min(totalFrames - 1, idx));
  currentFrame = idx;
  scrubber.value = idx;
  updateFrameLabel(idx);

  // Hide previous frustum
  if (activeFrustum) {
    activeFrustum.visible = false;
  }

  // Show frustum for this frame (or nearest registered)
  let f = frustums[idx];
  if (!f) {
    // Find nearest registered
    let best = null, bestDist = Infinity;
    for (let i = 0; i < frustums.length; i++) {
      if (frustums[i] && Math.abs(i - idx) < bestDist) {
        bestDist = Math.abs(i - idx);
        best = frustums[i];
      }
    }
    f = best;
  }
  if (f) {
    f.visible = true;
    activeFrustum = f;
  }

  // Info panel: current frame
  const fd = frameData[idx];
  if (fd) {
    document.getElementById("ip-frame").textContent = `${idx + 1} / ${totalFrames}`;
    document.getElementById("ip-reg2").textContent  = fd.registered ? "YES" : "—";
  }

  // Per-frame point cloud swap (when frame clouds have been loaded)
  if (frameCloudMode) {
    if (activeFrameCloud) activeFrameCloud.visible = false;
    let cloud = framePoints[idx];
    if (!cloud) {
      // Find nearest loaded frame cloud
      let bestDist = Infinity;
      for (let i = 0; i < framePoints.length; i++) {
        if (framePoints[i] && Math.abs(i - idx) < bestDist) {
          bestDist = Math.abs(i - idx);
          cloud = framePoints[i];
        }
      }
    }
    if (cloud) {
      cloud.visible = true;
      activeFrameCloud = cloud;
    }
  }

  // Follow-camera: snap Three.js camera to COLMAP pose for this frame.
  // COLMAP world → Three.js world: flip Y and Z (OpenCV→OpenGL convention).
  // rotation_matrix (R^T) rows are camera basis vectors in COLMAP world space:
  //   R^T[0] = right,  R^T[1] = down,  R^T[2] = forward (into scene)
  // We update controls.target (not disable controls) so OrbitControls keeps working.
  if (followCam && fd && fd.registered && fd.position && fd.rotation_matrix) {
    const pos  = fd.position;
    const rotT = fd.rotation_matrix;
    // Camera position in Three.js world (Y/Z flipped)
    camera.position.set(pos[0], -pos[1], -pos[2]);
    // Up = -R^T[1] (COLMAP Y is down, Three.js Y is up)
    camera.up.set(-rotT[1][0], rotT[1][1], rotT[1][2]);
    // Orbit target = camera pos + forward direction (R^T[2]), Y/Z flipped
    controls.target.set(
      pos[0] + rotT[2][0],
      -pos[1] - rotT[2][1],
      -pos[2] - rotT[2][2]
    );
    controls.update();
  }
}

function updateFrameLabel(idx) {
  frameLabel.textContent = `${idx + 1} / ${totalFrames}`;
}

// ── Info panel ────────────────────────────────────────────────────────────────

function updateInfoPanel(sceneData) {
  const intr = sceneData.intrinsics || {};
  const reg  = sceneData.total_registered || 0;
  const tot  = sceneData.total_frames || 0;
  const err  = sceneData.solve_error;
  const pct  = tot > 0 ? Math.round(reg/tot*100) : 0;

  document.getElementById("ip-shot").textContent   = sceneData.shot_name || "—";
  document.getElementById("ip-frames").textContent  = tot;
  document.getElementById("ip-reg").textContent     = `${reg} / ${tot} (${pct}%)`;
  document.getElementById("ip-model").textContent   = intr.model || "—";
  const fl = intr.focal_length || intr.focal_length_x;
  document.getElementById("ip-focal").textContent   = fl ? `${fl.toFixed(1)} px` : "—";
  document.getElementById("ip-fov").textContent     = intr.fov_y_deg    ? `${intr.fov_y_deg.toFixed(1)}°`    : "—";

  const errEl = document.getElementById("ip-err");
  if (err != null) {
    const errStr = `${Number(err).toFixed(3)} px`;
    if (err < 1.0)      { errEl.textContent = errStr; errEl.className = "good"; }
    else if (err < 2.0) { errEl.textContent = errStr; errEl.className = "warn"; }
    else                { errEl.textContent = errStr; errEl.className = "bad";  }
  } else {
    errEl.textContent = "—"; errEl.className = "val";
  }
}

// ── Playback ──────────────────────────────────────────────────────────────────

function togglePlay() {
  if (totalFrames === 0) return;
  playing = !playing;
  playBtn.innerHTML = playing ? "&#9646;&#9646;" : "&#9654;";
  if (playing && currentFrame >= totalFrames - 1) {
    currentFrame = 0;
  }
  lastTime = null;
}

function animate(now) {
  requestAnimationFrame(animate);
  controls.update();

  if (playing && totalFrames > 0) {
    if (lastTime === null) lastTime = now;
    const dt = (now - lastTime) / 1000.0;
    lastTime = now;
    const nextFrame = currentFrame + dt * fps;
    if (nextFrame >= totalFrames) {
      playing = false;
      playBtn.innerHTML = "&#9654;";
      setFrame(totalFrames - 1);
    } else {
      setFrame(Math.floor(nextFrame));
    }
  }

  renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// ── Loading overlay helpers ───────────────────────────────────────────────────

const loadingBar = document.getElementById("loading-bar");

function showLoading(msg, pct) {
  loadingMsg.textContent = msg || "Loading…";
  loadingDiv.classList.remove("hidden");
  if (pct !== undefined) loadingBar.style.width = Math.round(pct) + "%";
}

function hideLoading() {
  loadingDiv.classList.add("hidden");
  loadingBar.style.width = "0%";
}

// ── Event wiring ──────────────────────────────────────────────────────────────

loadBtn.addEventListener("click", () => {
  const shot = shotSelect.value;
  if (!shot) { statusMsg.textContent = "Select a shot first"; return; }
  loadShot(shot);
});

scrubber.addEventListener("input", () => {
  playing = false;
  playBtn.innerHTML = "&#9654;";
  setFrame(parseInt(scrubber.value, 10));
});

playBtn.addEventListener("click", togglePlay);

resetBtn.addEventListener("click", () => {
  followCam = false;
  followBtn.classList.remove("active");
  controls.reset();
});

followBtn.addEventListener("click", () => {
  followCam = !followCam;
  followBtn.classList.toggle("active", followCam);
  if (followCam) {
    setFrame(currentFrame);  // immediately snap to current frame's pose
  }
});

// Keyboard shortcuts
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "SELECT" || e.target.tagName === "INPUT") return;
  if (e.key === " ") { e.preventDefault(); togglePlay(); }
  if (e.key === "ArrowRight") { playing = false; playBtn.innerHTML = "&#9654;"; setFrame(currentFrame + 1); }
  if (e.key === "ArrowLeft")  { playing = false; playBtn.innerHTML = "&#9654;"; setFrame(currentFrame - 1); }
  if (e.key === "Home")       { playing = false; playBtn.innerHTML = "&#9654;"; setFrame(0); }
  if (e.key === "End")        { playing = false; playBtn.innerHTML = "&#9654;"; setFrame(totalFrames - 1); }
});

// ── Init ──────────────────────────────────────────────────────────────────────

(async () => {
  await populateShots();
  // If embedded with ?shot=... param, select and load that shot
  const urlShot = new URLSearchParams(window.location.search).get("shot");
  if (urlShot) {
    shotSelect.value = urlShot;
    // If shot isn't in the list yet (new solve just finished), add it
    if (!shotSelect.value) {
      const opt = document.createElement("option");
      opt.value = opt.textContent = urlShot;
      shotSelect.appendChild(opt);
      shotSelect.value = urlShot;
    }
    try {
      await loadShot(urlShot);
    } catch (e) {
      console.error("loadShot failed:", e);
      statusMsg.textContent = "Load failed: " + e.message;
      hideLoading();
    }
  } else if (shotSelect.value) {
    // Standalone: auto-load first shot
    hideLoading();
  } else {
    hideLoading();
  }
})();
</script>
</body>
</html>
